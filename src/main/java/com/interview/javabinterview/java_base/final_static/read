第一次实例化WithFinalFields的时候，虚拟机发现该类没有被加载，于是先加载类，加载类的同时需要初始化
类的所有static无论是变量、常量还是块，于是wffs需要实例化一个SelfCounter对象，这个时候虚拟机发现
SelfCounter类也没有被加载，于是加载SelfCounter类，同时初始化static变量counter为0，加载SelfCounter
类完毕，开始实例化SelfCounter对象，初始化id为0（此时counter为0），同时counter变为1，这时SelfCounter
对象的实例化完毕，并被赋值给WithFinalFields类的wffs常量，加载WithFinalFields类的过程完毕，
开始正式实例化WithFinalFields对象，初始化wff常量，又需要实例化一个SelfCounter对象，这时虚拟机发现
SelfCounter类已经被加载，于直接开始实例化SelfCounter对象，初始化id为1（此时counter为1），
同时counter变为2，实例化WithFinalFields对象完毕，此时wffs的id为0，wff的id为1。

第二次实例化WithFinalFields的时候，虚拟机发现该类已经被加载，直接实例化，不会初始化static无论是
变量、常量还是块，于是直接初始化wff常量，需要实例化SelfCounter对象，该类也已经被加载，于是也直接
实例化，初始化id为2（此时counter为2），同时counter变为3，实例化SelfCounter对象完毕，同时实例化
WithFinalFields对象完毕，此时wffs的id仍然为0，wff的id为2。

重点是静态的东西只会被初始化一次，发生在类加载的时候。

static的常量在类加载的时候被初始化，而实例常量在实例化的时候被初始化。

final是不可变，但问题是有两个WithFinalFields对象，每个WithFinalFields对象都有它自己的wff常量，
而且对于引用类型的常量，所谓不可变仅仅是引用不能重新指向其他对象，
而不是对象内部的各种属性的值不可变